# Браузер
## Содержание
1. [Загрузка страницы](#загрузка-страницы)
	- [Этапы загрузки страницы](#этапы-загрузки-страницы)
2. [Рендер страницы](#рендер-страницы)
	- [Этапы рендера страницы](#этапы-рендера-страницы)
	- [Оптимизации рендера](#оптимизации-рендера)
	- [Особенности рендера](#особенности-рендера)
		- [Исполнение JS-кода](#исполнение-js-кода)
		- [Особенности composite](#особенности-composite)
3. [Мета-директивы](#мета-директивы)
	- [Preload](#preload)
	- [Prefetch](#prefetch)
	- [Preconnect](#preconnect)

## Загрузка страницы
### Этапы загрузки страницы
Когда пользователь вводит адрес сайта в браузер, происходит следующее:
1. Сначала браузер смотрит в свой локальный кэш DNS. Если там нет нужной записи, то браузер передаёт управление ОС, которая смотрит в свой кэш DNS. Если же нигде нет записи, то браузер обращается к DNS-серверу, чтобы получить реальный IP адрес этого сервера. Этот процесс называется **DNS lookup**.
2. Далее браузер, используя полученный IP, обращается к серверу с просьбой отправить копию сайта для клиета. Посылается запрос на 80 порт в случае HTTP и 443 в случае HTTPS. Это обращение и все последующие происходят по TCP/IP.
3. Если запрос клиента корректен, то бразуер отправлят ответ 200 OK, а затем начинает передавать данные в виде пакетов.
4. Далее в браузере происходит [рендер страницы](#рендер-страницы).

##  Рендер страницы
### Этапы рендера страницы

1) Формирование **DOM** из полученного HTML документа. Объект доступен в переменной document.
2) Загрузка стилей CSS и формирование **CSSDOM**. Стили доступны в document.styleSheets.
3) Используя DOM и CSSDOM браузер выстраивает **render tree** (набор объектов рендеринга). Render tree дублирует структуру DOM, но с некоторыми отличиями:
	- В него не попадают невидимые элементы (например, head или элементы с display: none)
	- Каждая строка текста представлена в виде отдельного renderer
	
	Каждый объект renderer содержит в себе соответствующий объект DOM (или текст), а также рассчитанные стили. 
4) Для каждого объекта в render tree происходит рассчёт положения на странице (**layout**). Браузеры используют поточный метод *flow*, с помощью которого в большинстве случаев достаточно одного прохода по дереву для определения положения (для таблиц, обычно, нужно больше проходов).
5) Затем идёт отрисовка или **painting** (вычисление цвета каждого пикселя).
6) Завершающий этап - **composite**. Компоненты рисуются слой за слоем.

В процессе взаимодействия пользователя со страницей (например, при изменении стилей или js-манипуляциях), некоторые этапы приходится запускать заново:

1) В случаях, когда положение элемента на странице не меняется (например, изменяются такие css-стили как: border-color, visibility, background-color...) выполняется **repaint** (т. е. браузер отрисует его заново без пересчёта позиции и прочего).
2) Когда же происходит изменение структуры документа, положение элементов, то происходит **reflow**.

### Оптимизации рендера

1. **Локализация изменений**

Браузеры локализуют **repaint** и **reflow** в пределах изменённых элементов. Например, при изменении абсолютно или фиксировано спозиционированного элемента браузер затронет только элемент и его потомков, а при изменении статично спозиционированного элемента - весь документ.

2. **Кэширование изменений**

Браузер старается кэшировать изменения, которые происходят в js-коде, и применять их в один проход после завершения исполнения блока кода. 
```
var $body = $('body');
$body.css('padding', '1px'); // reflow, repaint
$body.css('color', 'red'); // repaint
$body.css('margin', '2px'); // reflow, repaint
// На самом деле произойдет только 1 reflow и repaint
```
Однако, как описано выше, обращение к свойствам элементов вызовет принудительный reflow. То есть, если мы в приведённый блок кода добавим обращение к свойству элемента, это вызовет лишний reflow:
```
var $body = $('body');
$body.css('padding', '1px');
$body.css('padding'); // обращение к свойству, принудительный reflow
$body.css('color', 'red');
$body.css('margin', '2px');
```

### Особенности рендера

#### Исполнение JS-кода
Браузер старается загружать ресуры (картинки, скрипты...) параллельно, но он не может загружать более 6 ресурсов сразу с одного домена.

Когда браузер доходит до обработки скрипта, то в дело вступает JavaScript interpreter, который преобразует байты в исполняемый код:
1) Байты
2) Символы
3) Токены
4) Abstract syntax tree (AST)

После этого компилятор оптимизирует *AST*, выполняет кэширование некоторых участков, компилирует код на лету в исполяемый (**JIT-compilation** или Just-in-time) и исполняет его.

#### Особенности **composite**
Элементы, которые содержат в стилях *opacity*, *transform* и *will-change*, выносятся в отдельный слой, а их обработка отдаётся GPU.

## Мета-директивы
Следующие директивы поддерживаются не всеми браузерами.

### Preload
Директива **Preload** позволяет предварительно загрузить ресурсы (CSS, JS, ...) для текущей навигации с высоким приоритетом.
```
<link rel="preload" href="/script.js" as=["script", "style", "image", "document"...]>
```
**Замечание:** при предварительной загрузке связей с разрешенными CORS-ресурсами необходим атрибут *crossorigin*.

### Prefetch
Директива **Prefetch** позволяет браузеру загружать ресурсы с низким приоритетом в фоновом режиме для дальнейшего исполоьзования и сохранять их в кэше.

Существует три типа prefetch:
1) **Ссылочный prefetch**
Cсылочный prefetch позволяет браузеру выбрать ресурсы и сохранить их в кэше, предполагая, что *потом* пользователь их запросит.
```
<link rel="prefetch" href="/pic.jpg">
```
**Замечание:**

> Эта техника ускорит многие интерактивные сайты, но не будет работать всегда и везде по следующим причинам:
> 1. Для некоторых сайтов трудно угадать, что пользователь собирается делать.
> 2. Для других сайтов сохраненные в кэше данные устаревают, если пользователь быстро выбирает новые.
> 3. Опасно постоянно сохранять файлы в кэше — просмотр текущей страницы замедлится».
> *Google Developers*

2) **DNS-prefetch**

DNS prefetch позволяет браузеру выполнять поиск DNS на странице в фоновом режиме, в то время как пользователь просматривает сайт. Это минимизирует время ожидания, поскольку поиск DNS уже состоялся, когда пользователь щелкнет по ссылке.
```
<link rel="dns-prefetch" href="//fonts.googleapis.com">
```

3) **Prerender**

Prerender принимает в фоновом режиме **всю страницу**, все содержание документа.
```
<link rel="prerender" href="https://www.keycdn.com">
```
**Замечание:**
> Подсказка prerender используется приложением для указания следующей вероятной цели HTML-навигации. При этом пользовательский > агент выберет и обработает указанный ресурс как HTML-ответ. А вот для того, чтобы выбрать другой тип контента, или же когда > предварительная обработка HTML нежелательна, приложение использует другую подсказку — prefetch.
> *W3C*

### Preconnect
Preconnect позволяет браузеру **установить соединение прежде, чем HTTP-запрос будет отправлен на сервер**. Эта процедура включает поиски DNS, «переговоры» TLS и «рукопожатие» TCP. Что в свою очередь устраняет круговые задержки и экономит время пользователя.

```
<link href="https://cdn.domain.com" rel="preconnect" crossorigin>
```
> Preconnect — важный инструмент оптимизации… он устраняет дорогостоящие круговые задержки из пути запроса. Иногда время ожидания запроса сокращается на сотни и даже тысячи миллисекунд.
> Илья Григорик (англ. Ilya Grigorik)
